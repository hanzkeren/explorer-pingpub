"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.experimentalSuggestChain = exports.suggestChain = exports.isLocalSnap = exports.getKey = exports.requestSignAmino = exports.requestSignature = exports.getSnap = exports.connectSnap = exports.getSnaps = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const long_1 = __importDefault(require("long"));
const config_1 = require("./config");
const chainInfo_1 = __importDefault(require("./constants/chainInfo"));
const gas_1 = require("./helper/gas");
/**
 * The fool proof version of getting the ethereum provider suggested by
 * https://github.com/Montoya/snap-connect-test/blob/0dad2dd53ab2ecbf4b4369230d3aaaeca08c6dae/index.html#L41
 *
 * @returns the ethereum provider which supports snaps
 */
const getProvider = async () => {
    let mmFound = false;
    if ('detected' in window.ethereum) {
        for (const provider of window.ethereum.detected) {
            try {
                // Detect snaps support
                await provider.request({
                    method: 'wallet_getSnaps',
                });
                // enforces MetaMask as provider
                window.ethereum.setProvider(provider);
                mmFound = true;
                return provider;
            }
            catch (_a) {
                // no-op
            }
        }
    }
    if (!mmFound && 'providers' in window.ethereum) {
        for (const provider of window.ethereum.providers) {
            try {
                // Detect snaps support
                await provider.request({
                    method: 'wallet_getSnaps',
                });
                window.ethereum = provider;
                mmFound = true;
                return provider;
            }
            catch (_b) {
                // no-op
            }
        }
    }
    return window.ethereum;
};
const sendReqToSnap = async (method, params) => {
    const provider = await getProvider();
    return provider.request({
        method: 'wallet_invokeSnap',
        params: {
            snapId: config_1.defaultSnapOrigin,
            request: {
                method,
                params,
            },
        },
    });
};
/**
 * Get the installed snaps in MetaMask.
 *
 * @returns The snaps installed in MetaMask.
 */
const getSnaps = async () => {
    const provider = await getProvider();
    return (await provider.request({
        method: 'wallet_getSnaps',
    }));
};
exports.getSnaps = getSnaps;
/**
 * Connect a snap to MetaMask.
 *
 * @param snapId - The ID of the snap.
 * @param params - The params to pass with the snap to connect.
 */
const connectSnap = async (snapId = config_1.defaultSnapOrigin, params = {}) => {
    const provider = await getProvider();
    return provider.request({
        method: 'wallet_requestSnaps',
        params: {
            [snapId]: params,
        },
    });
};
exports.connectSnap = connectSnap;
/**
 * Get the snap from MetaMask.
 *
 * @param version - The version of the snap to install (optional).
 * @returns The snap object returned by the extension.
 */
const getSnap = async (version) => {
    try {
        const snaps = await (0, exports.getSnaps)();
        return Object.values(snaps).find((snap) => snap.id === config_1.defaultSnapOrigin && (!version || snap.version === version));
    }
    catch (e) {
        console.log('Failed to obtain installed snap', e);
        return undefined;
    }
};
exports.getSnap = getSnap;
const requestSignature = async (chainId, signerAddress, signDoc) => {
    const signature = await sendReqToSnap('signDirect', {
        chainId,
        signerAddress,
        signDoc: Object.assign(Object.assign({}, signDoc), { accountNumber: long_1.default.fromString(signDoc.accountNumber.toString(), true) }),
    });
    const modifiedSignature = {
        signature: signature.signature,
        signed: Object.assign(Object.assign({}, signature.signed), { accountNumber: signDoc.accountNumber.toString(), authInfoBytes: new Uint8Array(Object.values(signature.signed.authInfoBytes)), bodyBytes: new Uint8Array(Object.values(signature.signed.bodyBytes)) }),
    };
    return modifiedSignature;
};
exports.requestSignature = requestSignature;
const requestSignAmino = async (chainId, signerAddress, signDoc, options) => {
    const { isADR36 = false, enableExtraEntropy = false } = options || {};
    if (!isADR36 && chainId !== signDoc.chain_id) {
        throw new Error('Chain ID does not match signer chain ID');
    }
    const chain = chainInfo_1.default[chainId];
    // Override gasPrice
    if (!(options === null || options === void 0 ? void 0 : options.preferNoSetFee) && chain && chain.denom) {
        const gasPriceFromRegistry = await (0, gas_1.getGasPriceForChainName)(chain.chainName);
        const gas = 'gasLimit' in signDoc.fee ? signDoc.fee.gasLimit : signDoc.fee.gas;
        if (gasPriceFromRegistry) {
            const amount = [
                {
                    amount: new bignumber_js_1.default(gasPriceFromRegistry)
                        .multipliedBy(new bignumber_js_1.default(gas))
                        .decimalPlaces(0, 1)
                        .toString(),
                    denom: chain.denom,
                },
            ];
            signDoc.fee.amount = amount;
        }
    }
    const signResponse = (await sendReqToSnap('signAmino', {
        chainId,
        signerAddress,
        signDoc,
        isADR36,
        enableExtraEntropy,
    }));
    return signResponse;
};
exports.requestSignAmino = requestSignAmino;
const getKey = async (chainId) => {
    const accountData = await sendReqToSnap('getKey', {
        chainId,
    });
    if (!accountData) {
        throw new Error('No account data found');
    }
    accountData.pubkey = Uint8Array.from(Object.values(accountData.pubkey));
    return accountData;
};
exports.getKey = getKey;
const isLocalSnap = (snapId) => snapId.startsWith('local:');
exports.isLocalSnap = isLocalSnap;
const suggestChain = async (chainInfo, options) => {
    if (options && options.force) {
        return await sendReqToSnap('suggestChain', {
            chainInfo,
        });
    }
    const supportedChains = (await sendReqToSnap('getSupportedChains', {})) || {};
    if (supportedChains[chainInfo.chainId]) {
        return Promise.resolve({
            message: 'Chain already added successfully',
            chainInfo,
        });
    }
    return await sendReqToSnap('suggestChain', {
        chainInfo,
    });
};
exports.suggestChain = suggestChain;
// For supporting existing providers.
exports.experimentalSuggestChain = exports.suggestChain;
//# sourceMappingURL=snap.js.map