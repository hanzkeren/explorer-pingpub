var ae = Object.defineProperty;
var ce = (s, a, n) => a in s ? ae(s, a, { enumerable: !0, configurable: !0, writable: !0, value: n }) : s[a] = n;
var f = (s, a, n) => (ce(s, typeof a != "symbol" ? a + "" : a, n), n);
import { CosmWasmClient as ie } from "@cosmjs/cosmwasm-stargate";
import * as oe from "js-sha3";
import { toUnicode as de } from "idna-uts46-hx";
var j = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", W = {};
for (var U = 0; U < j.length; U++) {
  var k = j.charAt(U);
  if (W[k] !== void 0)
    throw new TypeError(k + " is ambiguous");
  W[k] = U;
}
function O(s) {
  var a = s >> 25;
  return (s & 33554431) << 5 ^ -(a >> 0 & 1) & 996825010 ^ -(a >> 1 & 1) & 642813549 ^ -(a >> 2 & 1) & 513874426 ^ -(a >> 3 & 1) & 1027748829 ^ -(a >> 4 & 1) & 705979059;
}
function Y(s) {
  for (var a = 1, n = 0; n < s.length; ++n) {
    var e = s.charCodeAt(n);
    if (e < 33 || e > 126)
      return "Invalid prefix (" + s + ")";
    a = O(a) ^ e >> 5;
  }
  for (a = O(a), n = 0; n < s.length; ++n) {
    var t = s.charCodeAt(n);
    a = O(a) ^ t & 31;
  }
  return a;
}
function le(s, a, n) {
  if (n = n || 90, s.length + 7 + a.length > n)
    throw new TypeError("Exceeds length limit");
  s = s.toLowerCase();
  var e = Y(s);
  if (typeof e == "string")
    throw new Error(e);
  for (var t = s + "1", r = 0; r < a.length; ++r) {
    var c = a[r];
    if (c >> 5)
      throw new Error("Non 5-bit word");
    e = O(e) ^ c, t += j.charAt(c);
  }
  for (r = 0; r < 6; ++r)
    e = O(e);
  for (e ^= 1, r = 0; r < 6; ++r) {
    var d = e >> (5 - r) * 5 & 31;
    t += j.charAt(d);
  }
  return t;
}
function Z(s, a) {
  if (a = a || 90, s.length < 8)
    return s + " too short";
  if (s.length > a)
    return "Exceeds length limit";
  var n = s.toLowerCase(), e = s.toUpperCase();
  if (s !== n && s !== e)
    return "Mixed-case string " + s;
  s = n;
  var t = s.lastIndexOf("1");
  if (t === -1)
    return "No separator character for " + s;
  if (t === 0)
    return "Missing prefix for " + s;
  var r = s.slice(0, t), c = s.slice(t + 1);
  if (c.length < 6)
    return "Data too short";
  var d = Y(r);
  if (typeof d == "string")
    return d;
  for (var w = [], h = 0; h < c.length; ++h) {
    var l = c.charAt(h), m = W[l];
    if (m === void 0)
      return "Unknown character " + l;
    d = O(d) ^ m, !(h + 6 >= c.length) && w.push(m);
  }
  return d !== 1 ? "Invalid checksum for " + s : { prefix: r, words: w };
}
function he() {
  var s = Z.apply(null, arguments);
  if (typeof s == "object")
    return s;
}
function we(s) {
  var a = Z.apply(null, arguments);
  if (typeof a == "object")
    return a;
  throw new Error(a);
}
function F(s, a, n, e) {
  for (var t = 0, r = 0, c = (1 << n) - 1, d = [], w = 0; w < s.length; ++w)
    for (t = t << a | s[w], r += a; r >= n; )
      r -= n, d.push(t >> r & c);
  if (e)
    r > 0 && d.push(t << n - r & c);
  else {
    if (r >= a)
      return "Excess padding";
    if (t << n - r & c)
      return "Non-zero padding";
  }
  return d;
}
function me(s) {
  var a = F(s, 8, 5, !0);
  if (Array.isArray(a))
    return a;
}
function fe(s) {
  var a = F(s, 8, 5, !0);
  if (Array.isArray(a))
    return a;
  throw new Error(a);
}
function ue(s) {
  var a = F(s, 5, 8, !1);
  if (Array.isArray(a))
    return a;
}
function ve(s) {
  var a = F(s, 5, 8, !1);
  if (Array.isArray(a))
    return a;
  throw new Error(a);
}
var p = {
  decodeUnsafe: he,
  decode: we,
  encode: le,
  toWordsUnsafe: me,
  toWords: fe,
  fromWordsUnsafe: ue,
  fromWords: ve
}, i = /* @__PURE__ */ ((s) => (s.NETWORK = "network", s.NOT_FOUND = "not-found", s.UNREGISTERED_SERVICE = "unregistered-service", s.DUPLICATE_SERVICE = "duplicate-service", s.INVALID_ADDRESS = "invalid-address", s.UNAVAILABLE_METHOD = "invalid-address", s))(i || {});
class o extends Error {
  constructor(n, e) {
    super(n);
    f(this, "type");
    this.name = "MatchaError", this.type = e;
  }
}
const I = class {
};
let D = I;
f(D, "clients", {}), f(D, "getClient", async (a) => {
  let n = I.clients[a];
  return n === void 0 && (n = await ie.connect(a), I.clients[a] = n), n;
});
class y {
  /**
   * @param network The network to use
   */
  getCosmWasmClient(a) {
    return D.getClient(a);
  }
}
const P = {
  mainnet: "https://rpc.cosmos.directory/osmosis",
  testnet: "https://rpc-test.osmosis.zone"
}, A = "icns";
class pe extends y {
  constructor() {
    super(...arguments);
    f(this, "serviceID", A);
    f(this, "chain", "osmosis");
    f(this, "contractAddress", {
      mainnet: "osmo1xk0s8xgktn9x5vwcgtjdxqzadg88fgn33p8u9cnpdxwemvxscvast52cdd",
      testnet: "osmo1q2qpencrnnlamwalxt6tac2ytl35z5jejn0v4frnp6jff7gwp37sjcnhu5"
    });
  }
  async resolve(n, e, t) {
    var w, h, l, m;
    const r = await this.getCosmWasmClient(
      ((h = (w = t == null ? void 0 : t.rpcUrls) == null ? void 0 : w[A]) == null ? void 0 : h[e]) ?? P[e]
    ), [c, d] = n.split(".");
    try {
      const u = await (r == null ? void 0 : r.queryContractSmart(
        this.contractAddress[e],
        {
          address: {
            name: c,
            bech32_prefix: d
          }
        }
      ));
      if (!(u != null && u.address) || ((m = (l = t == null ? void 0 : t.allowedTopLevelDomains) == null ? void 0 : l.icns) == null ? void 0 : m.indexOf(d)) === -1)
        throw new o("", i.NOT_FOUND);
      return u.address;
    } catch {
      throw new o("", i.NOT_FOUND);
    }
  }
  async lookup(n, e, t) {
    var d, w;
    const r = await this.getCosmWasmClient(
      ((w = (d = t == null ? void 0 : t.rpcUrls) == null ? void 0 : d[A]) == null ? void 0 : w[e]) ?? P[e]
    ), c = {
      prefix: null,
      words: null
    };
    try {
      const { prefix: h, words: l } = p.decode(n);
      c.prefix = h, c.words = l;
    } catch {
      throw new o("", i.INVALID_ADDRESS);
    }
    try {
      const h = await (r == null ? void 0 : r.queryContractSmart(
        this.contractAddress[e],
        {
          primary_name: {
            address: n
          }
        }
      ));
      if (!(h != null && h.name))
        throw new o("", i.NOT_FOUND);
      return `${h.name}.${c.prefix}`;
    } catch {
      throw new o("", i.NOT_FOUND);
    }
  }
}
const B = {
  mainnet: "https://rpc.cosmos.directory/juno",
  testnet: "https://rpc.uni.kingnodes.com"
}, S = "ibcDomains";
class ye extends y {
  constructor() {
    super(...arguments);
    f(this, "serviceID", S);
    f(this, "chain", "juno");
    f(this, "contractAddress", {
      mainnet: "juno1ce7wjfsuk79t2mdvpdjtv8280pcc64yh9mh62qptuvxe64twt4pqa68z2a",
      testnet: "juno19al2ptpxz3xk6q8nl3eyvyslkz8g6nz25w48dfpaepwaxavq3mhqsjjqe5"
    });
  }
  async resolve(n, e, t) {
    var w, h, l, m;
    const r = await this.getCosmWasmClient(
      ((h = (w = t == null ? void 0 : t.rpcUrls) == null ? void 0 : w[S]) == null ? void 0 : h[e]) ?? B[e]
    ), [c, d] = n.split(".");
    try {
      const u = await (r == null ? void 0 : r.queryContractSmart(
        this.contractAddress[e],
        {
          owner_of: {
            token_id: c
          }
        }
      ));
      if (!(u != null && u.owner) || ((m = (l = t == null ? void 0 : t.allowedTopLevelDomains) == null ? void 0 : l.ibcDomains) == null ? void 0 : m.indexOf(d)) === -1)
        throw new o("", i.NOT_FOUND);
      try {
        const { words: v } = p.decode(u.owner);
        return p.encode(d, v);
      } catch {
        throw new o("", i.NOT_FOUND);
      }
    } catch {
      throw new o("", i.NOT_FOUND);
    }
  }
  async lookup(n, e, t) {
    var w, h;
    const r = await this.getCosmWasmClient(
      ((h = (w = t == null ? void 0 : t.rpcUrls) == null ? void 0 : w[S]) == null ? void 0 : h[e]) ?? B[e]
    ), c = {
      prefix: null,
      words: null
    };
    try {
      const { prefix: l, words: m } = p.decode(n);
      c.prefix = l, c.words = m;
    } catch {
      throw new o("", i.INVALID_ADDRESS);
    }
    const d = p.encode("juno", c.words);
    try {
      const l = await (r == null ? void 0 : r.queryContractSmart(
        this.contractAddress[e],
        {
          primary_domain: {
            address: d
          }
        }
      ));
      if (!(l != null && l.domain))
        throw new o("", i.NOT_FOUND);
      return `${l.domain}.${c.prefix}`;
    } catch {
      throw new o("", i.NOT_FOUND);
    }
  }
}
const G = {
  mainnet: "https://rpc.cosmos.directory/stargaze",
  testnet: "https://rpc.elgafar-1.stargaze-apis.com"
}, C = "stargazeNames";
class Ne extends y {
  constructor() {
    super(...arguments);
    f(this, "serviceID", C);
    f(this, "chain", "stargaze");
    f(this, "contractAddress", {
      mainnet: "stars1fx74nkqkw2748av8j7ew7r3xt9cgjqduwn8m0ur5lhe49uhlsasszc5fhr",
      testnet: "stars1rp5ttjvd5g0vlpltrkyvq62tcrdz949gjtpah000ynh4n2laz52qarz2z8"
    });
  }
  async resolve(n, e, t) {
    var w, h, l, m;
    const r = await this.getCosmWasmClient(
      ((h = (w = t == null ? void 0 : t.rpcUrls) == null ? void 0 : w[C]) == null ? void 0 : h[e]) ?? G[e]
    ), [c, d] = n.split(".");
    try {
      const u = await r.queryContractSmart(
        this.contractAddress[e],
        {
          associated_address: {
            name: c
          }
        }
      );
      if (!u || ((m = (l = t == null ? void 0 : t.allowedTopLevelDomains) == null ? void 0 : l.stargazeNames) == null ? void 0 : m.indexOf(d)) === -1)
        throw new o("", i.NOT_FOUND);
      try {
        const { words: v } = p.decode(u);
        return p.encode(d, v);
      } catch {
        throw new o("", i.NOT_FOUND);
      }
    } catch {
      throw new o("", i.NOT_FOUND);
    }
  }
  async lookup(n, e, t) {
    var d, w;
    const r = await this.getCosmWasmClient(
      ((w = (d = t == null ? void 0 : t.rpcUrls) == null ? void 0 : d[C]) == null ? void 0 : w[e]) ?? G[e]
    ), c = {
      prefix: null,
      words: null
    };
    try {
      const { prefix: h, words: l } = p.decode(n);
      c.prefix = h, c.words = l;
    } catch {
      throw new o("", i.INVALID_ADDRESS);
    }
    try {
      return `${await r.queryContractSmart(
        this.contractAddress[e],
        {
          name: {
            address: n
          }
        }
      )}.${c.prefix}`;
    } catch {
      throw new o("", i.NOT_FOUND);
    }
  }
}
const J = {
  mainnet: "https://rpc.mainnet.archway.io",
  testnet: "https://rpc.constantine.archway.tech"
}, T = "archIds";
class ge extends y {
  constructor() {
    super(...arguments);
    f(this, "serviceID", T);
    f(this, "chain", "archway");
    f(this, "contractAddress", {
      mainnet: "archway1275jwjpktae4y4y0cdq274a2m0jnpekhttnfuljm6n59wnpyd62qppqxq0",
      testnet: "archway1lr8rstt40s697hqpedv2nvt27f4cuccqwvly9gnvuszxmcevrlns60xw4r"
    });
  }
  // reference: https://gist.github.com/drewstaylor/088af645dd36c013c02a2b4d05110479#file-archid-resolve-address-js
  async resolve(n, e, t) {
    var d, w, h, l;
    const r = await this.getCosmWasmClient(
      ((w = (d = t == null ? void 0 : t.rpcUrls) == null ? void 0 : d[T]) == null ? void 0 : w[e]) ?? J[e]
    ), [, c] = n.split(".");
    try {
      const m = await (r == null ? void 0 : r.queryContractSmart(
        this.contractAddress[e],
        {
          resolve_record: {
            name: n
          }
        }
      ));
      if (!(m != null && m.address) || ((l = (h = t == null ? void 0 : t.allowedTopLevelDomains) == null ? void 0 : h.archIds) == null ? void 0 : l.indexOf(c)) === -1)
        throw new o("", i.NOT_FOUND);
      return m.address;
    } catch {
      throw new o("", i.NOT_FOUND);
    }
  }
  // reference: https://gist.github.com/drewstaylor/088af645dd36c013c02a2b4d05110479#file-archid-check-domains-resolve-to-address-js
  async lookup(n, e, t) {
    var d, w, h;
    const r = await this.getCosmWasmClient(
      ((w = (d = t == null ? void 0 : t.rpcUrls) == null ? void 0 : d[T]) == null ? void 0 : w[e]) ?? J[e]
    ), c = {
      prefix: null,
      words: null
    };
    try {
      const { prefix: l, words: m } = p.decode(n);
      c.prefix = l, c.words = m;
    } catch {
      throw new o("", i.INVALID_ADDRESS);
    }
    try {
      const l = await (r == null ? void 0 : r.queryContractSmart(
        this.contractAddress[e],
        {
          resolve_address: {
            address: n
          }
        }
      ));
      if (!(l != null && l.names) || !((h = l == null ? void 0 : l.names) != null && h.length))
        throw new o("", i.NOT_FOUND);
      return l.names.join(", ");
    } catch {
      throw new o("", i.NOT_FOUND);
    }
  }
}
const { keccak_256: H } = oe, Oe = (s) => s && de(s, { useStd3ASCII: !0 }), De = (s) => {
  if (!(s.startsWith("[") && s.endsWith("]")))
    throw Error(
      "Expected encoded labelhash to start and end with square brackets"
    );
  if (s.length !== 66)
    throw Error("Expected encoded labelhash to have a length of 66");
  return `${s.slice(1, -1)}`;
}, _e = (s) => s.startsWith("[") && s.endsWith("]") && s.length === 66, xe = (s) => {
  let a = "";
  for (let n = 0; n < 32; n++)
    a += "00";
  if (s) {
    const n = s.split(".");
    for (let e = n.length - 1; e >= 0; e--) {
      let t;
      if (_e(n[e]))
        t = De(n[e]);
      else {
        const r = Oe(n[e]);
        t = H(r);
      }
      a = H(Buffer.from(a + t, "hex"));
    }
  }
  return "0x" + a;
};
function Ue(s) {
  if (!s)
    return [];
  const a = xe(s);
  return Array.from(Buffer.from(a.slice(2), "hex"));
}
const g = {
  inj: {
    mainnet: "https://tm.injective.network",
    testnet: "https://testnet.tm.injective.dev"
  },
  sei: {
    mainnet: "https://rpc.wallet.pacific-1.sei.io",
    testnet: "https://sei-testnet-rpc.polkachu.com"
  }
}, ee = "spaceIds";
class Ae extends y {
  constructor() {
    super(...arguments);
    f(this, "serviceID", ee);
    f(this, "chain", ["injective", "sei"]);
    f(this, "contractAddress", {
      inj: {
        mainnet: "inj1x9m0hceug9qylcyrrtwqtytslv2jrph433thgu",
        testnet: "inj1ppneyx6qfnye26k9mwnf3ngyelvqng67f5v948"
      },
      sei: {
        mainnet: "sei1qujw7gxacyk08fpg0lsf377f727ldq8f9cmjlrxt6awdkag9ypjsdnkh98",
        testnet: "sei1a59k7mc9hsvtaeu532etl2geqmqdyufjncjkg0h3lxsu5u2rpensanaxwf"
      }
    });
  }
  async resolve(n, e, t) {
    var r, c, d;
    try {
      const [, w] = n.split("."), h = (r = g == null ? void 0 : g[w]) == null ? void 0 : r[e], l = this.contractAddress[w][e];
      if (h && l) {
        const m = await this.getCosmWasmClient(h), u = await (m == null ? void 0 : m.queryContractSmart(l, {
          address: {
            node: Ue(n)
          }
        }));
        if (!(u != null && u.address) || ((d = (c = t == null ? void 0 : t.allowedTopLevelDomains) == null ? void 0 : c.spaceIds) == null ? void 0 : d.indexOf(w)) === -1)
          throw new o("", i.NOT_FOUND);
        return u == null ? void 0 : u.address;
      } else
        throw new o("", i.NOT_FOUND);
    } catch {
      throw new o("", i.NOT_FOUND);
    }
  }
  async lookup(n, e) {
    var r;
    const t = {
      prefix: null,
      words: null
    };
    try {
      const { prefix: c, words: d } = p.decode(n);
      t.prefix = c, t.words = d;
    } catch {
      throw new o("", i.INVALID_ADDRESS);
    }
    try {
      const c = (r = g == null ? void 0 : g[t.prefix]) == null ? void 0 : r[e], d = this.contractAddress[t.prefix][e];
      if (c && d) {
        const w = await this.getCosmWasmClient(c), h = await (w == null ? void 0 : w.queryContractSmart(d, {
          name: {
            address: n.toLowerCase()
          }
        }));
        if (!(h != null && h.name))
          throw new o("", i.NOT_FOUND);
        return h.name.endsWith(t.prefix) ? h.name : h.name + t.prefix;
      } else
        throw new o("", i.NOT_FOUND);
    } catch {
      throw new o("", i.NOT_FOUND);
    }
  }
}
const te = "sns", K = {
  mainnet: "https://injective-rpc.publicnode.com:443",
  testnet: "https://testnet.sentry.tm.injective.network:443"
}, Se = (s) => s.endsWith(".sol") ? s.slice(0, -4) : s;
class Ce extends y {
  constructor() {
    super(...arguments);
    f(this, "serviceID", te);
    f(this, "chain", "injective");
    f(this, "contractAddress", {
      mainnet: "inj1v7chmgm7vmuwldjt80utmw9c95jkrch979ps8z",
      testnet: "inj1q79ujqyh72p43mhr2ldaly3x6d50rzp3354at3"
    });
  }
  async resolve(n, e) {
    const t = await this.getCosmWasmClient(K[e]);
    try {
      const r = await t.queryContractSmart(
        this.contractAddress[e],
        {
          resolve: {
            domain_name: Se(n)
          }
        }
      );
      if (!r)
        throw new o("", i.NOT_FOUND);
      return r;
    } catch {
      throw new o("", i.NOT_FOUND);
    }
  }
  async lookup(n, e) {
    var r, c;
    const t = await this.getCosmWasmClient(K[e]);
    try {
      const d = p.decode(n), w = p.fromWords(d.words), h = [...new Array(12).fill(0), ...w], l = await t.queryContractSmart(
        this.contractAddress[e],
        {
          get_domains_for_owner: {
            owner_chain: 19,
            owner_address: h,
            max_len: 1,
            domain_offset: void 0
          }
        }
      );
      if (!l)
        throw new o("", i.NOT_FOUND);
      const m = (c = (r = l == null ? void 0 : l.domains) == null ? void 0 : r.pop) == null ? void 0 : c.call(r);
      if (!m)
        throw new o("", i.NOT_FOUND);
      return m + ".sol";
    } catch {
      throw new o("", i.NOT_FOUND);
    }
  }
}
const z = "bdd", M = {
  mainnet: "https://full-node.mainnet-1.coreum.dev:26657",
  testnet: "https://full-node.testnet-1.coreum.dev:26657"
};
class Te extends y {
  constructor() {
    super(...arguments);
    f(this, "serviceID", z);
    f(this, "chain", "coreum");
    f(this, "contractAddress", {
      mainnet: "core1z22n0xy004sxm5w9fms48exwpl3vwqxd890nt8ve0kwjj048tgqstlqf6f",
      testnet: "testcore1uwe9yemth6gr58tm56sx3u37t0c5rhmk963fjt480y4nz3cfxers9fn2kh"
    });
  }
  async resolve(n, e) {
    const t = await this.getCosmWasmClient(M[e]);
    try {
      const r = await t.queryContractSmart(
        this.contractAddress[e],
        {
          resolve: {
            name: n
          }
        }
      );
      if (!r)
        throw new o("", i.NOT_FOUND);
      return r;
    } catch {
      throw new o("", i.NOT_FOUND);
    }
  }
  async lookup(n, e, t) {
    var h, l;
    const r = await this.getCosmWasmClient(
      ((l = (h = t == null ? void 0 : t.rpcUrls) == null ? void 0 : h[z]) == null ? void 0 : l[e]) ?? M[e]
    ), c = {
      prefix: null,
      words: null
    };
    try {
      const { prefix: m, words: u } = p.decode(n);
      c.prefix = m, c.words = u;
    } catch {
      throw new o("", i.INVALID_ADDRESS);
    }
    const d = e === "mainnet" ? "core" : "testcore", w = p.encode(d, c.words);
    try {
      const m = await (r == null ? void 0 : r.queryContractSmart(
        this.contractAddress[e],
        {
          primary: {
            address: w
          }
        }
      ));
      if (!m)
        throw new o("", i.NOT_FOUND);
      return m;
    } catch {
      throw new o("", i.NOT_FOUND);
    }
  }
}
const re = "nibId", je = {
  mainnet: "https://rpc.nibiru.fi:443",
  testnet: "https://rpc.testnet-2.nibiru.fi:443"
}, Ie = (s) => s.endsWith(".nibi") ? s.slice(0, -5) : s;
class Fe extends y {
  constructor() {
    super(...arguments);
    f(this, "serviceID", re);
    f(this, "chain", "nibiru");
    f(this, "contractAddress", {
      mainnet: "nibi1q0e70vhrv063eah90mu97sazhywmeegptx642t5px7yfcrf0rrsq2dylen",
      testnet: ""
    });
  }
  async resolve(n, e) {
    const t = await this.getCosmWasmClient(je[e]);
    if (this.contractAddress[e] == "")
      throw new o("", i.NOT_FOUND);
    try {
      const r = await t.queryContractSmart(
        this.contractAddress[e],
        {
          resolve_record: {
            name: Ie(n)
          }
        }
      );
      if (r == "" || r == null)
        throw new o("", i.NOT_FOUND);
      return r == null ? void 0 : r.address;
    } catch {
      throw new o("", i.NOT_FOUND);
    }
  }
  async lookup(n, e) {
    throw new o(`Lookup is unavailable for ${n} on ${e}`, i.UNAVAILABLE_METHOD);
  }
}
const se = "degeNS", Q = {
  mainnet: "https://rpc.sei-apis.com:443"
};
class qe extends y {
  constructor() {
    super(...arguments);
    f(this, "serviceID", se);
    f(this, "chain", "sei");
    f(this, "contractAddress", {
      mainnet: "sei10nulnfpdhx2wf7lp9kqa8aez2yxuyxwjyfw9rzlrexd500nhal0sl7mtzm",
      testnet: ""
    });
  }
  async resolve(n, e) {
    if (e === "testnet")
      throw new o(
        `Resolve is unavailable for ${n} on ${e}`,
        i.UNAVAILABLE_METHOD
      );
    const t = await this.getCosmWasmClient(Q[e]);
    if (this.contractAddress[e] == "")
      throw new o("", i.NOT_FOUND);
    try {
      const r = await t.queryContractSmart(
        this.contractAddress[e],
        {
          extension: {
            msg: {
              resolves_to: {
                domain_name: n
              }
            }
          }
        }
      );
      if (r == "" || r == null)
        throw new o("", i.NOT_FOUND);
      return r == null ? void 0 : r.address;
    } catch {
      throw new o("", i.NOT_FOUND);
    }
  }
  async lookup(n, e) {
    if (e === "testnet")
      throw new o(
        `Lookup is unavailable for ${n} on ${e}`,
        i.UNAVAILABLE_METHOD
      );
    const t = await this.getCosmWasmClient(Q[e]);
    if (this.contractAddress[e] == "")
      throw new o("", i.NOT_FOUND);
    try {
      const r = await t.queryContractSmart(
        this.contractAddress[e],
        {
          extension: {
            msg: {
              primary_of: {
                owner: n
              }
            }
          }
        }
      );
      if (r == "" || r == null)
        throw new o("", i.NOT_FOUND);
      return r == null ? void 0 : r.domain_name;
    } catch {
      throw new o("", i.NOT_FOUND);
    }
  }
}
const X = (s) => s.startsWith("0x") ? parseInt(s, 16).toString() : s, $ = {
  mainnet: "https://api.celestials.id",
  testnet: "https://api.stage.celestials.id"
}, _ = "celestialsId";
class be extends y {
  constructor() {
    super(...arguments);
    f(this, "serviceID", _);
    f(this, "chain", "celestia-1");
    f(this, "contractAddress", {
      mainnet: "",
      testnet: ""
    });
  }
  async getSupportedChains(n, e) {
    var r, c;
    const t = ((c = (r = e == null ? void 0 : e.rpcUrls) == null ? void 0 : r[_]) == null ? void 0 : c[n]) ?? $[n];
    try {
      const d = await fetch(`${t}/api/resolver/chains`);
      if (!d.ok)
        throw new o("", i.NOT_FOUND);
      return (await d.json()).chains;
    } catch {
      throw new o("", i.NOT_FOUND);
    }
  }
  async resolve(n, e, t) {
    var w, h, l, m, u;
    const r = ((h = (w = t == null ? void 0 : t.rpcUrls) == null ? void 0 : w[_]) == null ? void 0 : h[e]) ?? $[e], [c, d] = n.split(".");
    if (d && ((m = (l = t == null ? void 0 : t.allowedTopLevelDomains) == null ? void 0 : l.celestialsId) == null ? void 0 : m.indexOf(d)) === -1)
      throw new o("", i.NOT_FOUND);
    try {
      const v = await this.getSupportedChains(e, t), q = v.map((E) => ({
        celestials_id: c,
        chain_id: E.chain_id
      })), x = await fetch(`${r}/api/resolver/lookup`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          celestial_chain: q
        })
      });
      if (!x.ok)
        throw new o("", i.NOT_FOUND);
      const N = await x.json();
      if (!((u = N == null ? void 0 : N.addresses) != null && u.length))
        throw new o("", i.NOT_FOUND);
      const b = [];
      if (v.forEach((E, ne) => {
        var R;
        const V = (R = N.addresses[ne]) == null ? void 0 : R.address;
        V && b.push({
          chain_id: X(E.chain_id),
          address: V
        });
      }), b.length === 0)
        throw new o("", i.NOT_FOUND);
      return b;
    } catch {
      throw new o("", i.NOT_FOUND);
    }
  }
  async lookup(n, e, t) {
    var c, d;
    const r = ((d = (c = t == null ? void 0 : t.rpcUrls) == null ? void 0 : c[_]) == null ? void 0 : d[e]) ?? $[e];
    try {
      const w = await this.getSupportedChains(e, t), h = w.map((v) => ({
        address: n,
        chain_id: v.chain_id
      })), l = await fetch(`${r}/api/resolver/reverse_lookup`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          chain_addresses: h
        })
      });
      if (!l.ok)
        throw new o("", i.NOT_FOUND);
      const m = await l.json(), u = [];
      if (m.celestial_ids.forEach((v, q) => {
        var N;
        const x = w[q];
        (N = v == null ? void 0 : v[0]) != null && N.celestial_id && u.push({
          name: v[0].celestial_id,
          chain_id: X(x.chain_id)
        });
      }), u.length === 0)
        throw new o("", i.NOT_FOUND);
      return u;
    } catch {
      throw new o("", i.NOT_FOUND);
    }
  }
}
const L = [
  "agoric",
  "akash",
  "arkh",
  "axelar",
  "band",
  "bcna",
  "bitsong",
  "bostrom",
  "cerberus",
  "certik",
  "cheqd",
  "chihuahua",
  "chronic",
  "comdex",
  "cosmos",
  "crc",
  "cre",
  "cro",
  "cudos",
  "darc",
  "decentr",
  "desmos",
  "dig",
  "echelon",
  "emoney",
  "evmos",
  "fetch",
  "firma",
  "galaxy",
  "genesis",
  "gravity",
  "iaa",
  "inj",
  "ixo",
  "juno",
  "kava",
  "ki",
  "like",
  "logos",
  "lum",
  "mantle",
  "mars",
  "meme",
  "micro",
  "mythos",
  "nomic",
  "octa",
  "odin",
  "orai",
  "osmo",
  "panacea",
  "pb",
  "persistence",
  "regen",
  "rizon",
  "secret",
  "sent",
  "sif",
  "somm",
  "star",
  "stars",
  "swth",
  "terra",
  "thor",
  "umee",
  "vdl",
  "kujira",
  "sei",
  "stride",
  "jkl",
  "tori",
  "omniflix",
  "canto",
  "pasg",
  "archway",
  "quasar",
  "neutron",
  "testcore",
  "core",
  "quick",
  "migaloo",
  "kyve",
  "onomy",
  "noble",
  "plq",
  "nolus",
  "c4e",
  "gitopia",
  "nibi",
  "maya",
  "empower",
  "dydx"
], Ee = {
  icns: L,
  ibcDomains: L,
  stargazeNames: L,
  archIds: ["arch"],
  spaceIds: ["inj", "sei"],
  sns: ["sol"],
  nibId: ["nibi"],
  degeNS: ["pp", "sei"],
  bdd: ["core"],
  celestialsId: ["i"]
}, ze = {
  icns: A,
  ibcDomains: S,
  stargazeNames: C,
  archIds: T,
  spaceIds: ee,
  sns: te,
  bdd: z,
  nibId: re,
  degeNS: se,
  celestialsId: _
}, Ve = Ee;
class ke {
  constructor(a) {
    f(this, "services", {});
    this.network = a, this.network = a, this.registerService(new pe()), this.registerService(new ye()), this.registerService(new Ne()), this.registerService(new ge()), this.registerService(new Ae()), this.registerService(new Ce()), this.registerService(new Te()), this.registerService(new Fe()), this.registerService(new qe()), this.registerService(new be());
  }
  registerService(a) {
    if (this.services[a.serviceID])
      throw new o(
        "Service already registered",
        i.DUPLICATE_SERVICE
      );
    this.services[a.serviceID] = a;
  }
  getService(a) {
    const n = this.services[a];
    if (!n)
      throw new o(
        "Service not registered",
        i.UNREGISTERED_SERVICE
      );
    return n;
  }
  listServices() {
    return Object.keys(this.services);
  }
  setNetwork(a) {
    this.network = a;
  }
  getNetwork() {
    return this.network;
  }
  async resolve(a, n, e) {
    return this.getService(n).resolve(a, this.network, e);
  }
  async lookup(a, n, e) {
    return this.getService(n).lookup(a, this.network, e);
  }
  async resolveAll(a, n) {
    const e = {};
    return await Promise.all(
      Object.entries(this.services).map(async ([t, r]) => {
        try {
          const c = await r.resolve(a, this.network, n);
          e[t] = c;
        } catch {
          e[t] = null;
        }
      })
    ), e;
  }
  async lookupAll(a, n) {
    const e = {};
    return await Promise.all(
      Object.entries(this.services).map(async ([t, r]) => {
        try {
          const c = await r.lookup(a, this.network, n);
          e[t] = c;
        } catch {
          e[t] = null;
        }
      })
    ), e;
  }
}
const Re = new ke("mainnet");
export {
  Ve as allowedTopLevelDomains,
  Re as registry,
  ze as services
};
//# sourceMappingURL=index.es.js.map
